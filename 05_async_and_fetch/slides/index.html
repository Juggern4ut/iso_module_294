<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>Modul 294 – Lektion 05</title>

    <link rel="stylesheet" href="dist/reset.css" />
    <link rel="stylesheet" href="dist/reveal.css" />
    <link rel="stylesheet" href="dist/theme/black.css" />
    <link rel="stylesheet" href="plugin/highlight/monokai.css" />

    <style>
        td {
            font-size: 21px;
        }

        .inline-code {
            font-family: Consolas, Monaco, monospace;
            background-color: #2d2d2d;
            padding: 2px 4px;
            border-radius: 2px;
            font-size: 75%;
        }
    </style>
</head>

<body>
<div class="reveal">
<div class="slides">

<section>
    <h2>05 – Asynchrone Funktionen</h2>
    <hr />
    <h3>Promises, async / await & fetch</h3>
    <img style="width: 200px" src="assets/img/js-logo.webp" alt="JS Logo" />
</section>

<section>
    <h2>Lernziele dieser Lektion</h2>
    <ul>
        <li>Verstehen, was asynchroner Code ist</li>
        <li>Promises lesen und erstellen können</li>
        <li>Asynchrone Funktionen mit <span class="inline-code">async / await</span> schreiben</li>
        <li>Daten mit der <span class="inline-code">fetch</span>-Methode laden</li>
        <li>Fehler bei asynchronem Code behandeln</li>
    </ul>
</section>

<section>
    <h2>Synchron vs Asynchron</h2>
    <p>Synchroner Code wird Schritt für Schritt ausgeführt.</p>
    <p>Asynchroner Code erlaubt es, auf langsame Operationen zu warten, ohne das Programm zu blockieren.</p>
    <ul>
        <li>Timer</li>
        <li>Netzwerkanfragen</li>
        <li>Dateizugriffe</li>
    </ul>
</section>

<section>
    <h2>Warum Asynchronität?</h2>
    <ul>
        <li>JavaScript läuft standardmässig single-threaded</li>
        <li>Lange Aufgaben würden die Oberfläche blockieren</li>
        <li>Asynchroner Code sorgt für reaktive Anwendungen</li>
    </ul>
</section>

<section>
    <h2>Promises – Grundidee</h2>
    <p>Ein Promise steht für einen Wert, der jetzt noch nicht verfügbar ist.</p>
    <ul>
        <li>Erfüllt (<span class="inline-code">fulfilled</span>)</li>
        <li>Abgelehnt (<span class="inline-code">rejected</span>)</li>
        <li>Ausstehend (<span class="inline-code">pending</span>)</li>
    </ul>
</section>

<section>
    <h2>Ein einfaches Promise</h2>
    <pre><code class="js" data-trim data-line-numbers>
const promise = new Promise((resolve, reject) => {
    resolve("Fertig!");
});
    </code></pre>
</section>

<section>
    <h2>Promise verwenden</h2>
    <pre><code class="js" data-trim data-line-numbers>
promise.then(result => {
    console.log(result);
});
    </code></pre>

    <p><span class="inline-code">then</span> wird ausgeführt, wenn das Promise erfolgreich ist.</p>
</section>

<section>
    <h2>Promise mit Fehler</h2>
    <pre><code class="js" data-trim data-line-numbers>
const promise = new Promise((resolve, reject) => {
    reject("Etwas ist schiefgelaufen");
});
    </code></pre>
</section>

<section>
    <h2>Fehler behandeln</h2>
    <pre><code class="js" data-trim data-line-numbers>
promise
    .then(result => console.log(result))
    .catch(error => console.error(error));
    </code></pre>
</section>

<section>
    <h2>Komplettbeispiel</h2>
    <pre>
        <code class="js" data-trim data-line-numbers>
            const addAsync = (a,b) => {
                return new Promise((resolve, reject) =&gt; {
                    setTimeout(() =&gt; {
                        if(isNaN(a) || isNaN(b)) {
                            reject('Error: a or b is not a Number!');
                        } else {
                            resolve(a + b);
                        }
                    }, 1000);
                })
            }
        </code>
    </pre>
    <pre>
        <code class="js" data-trim data-line-numbers>
            console.log("Before");

            addAsync(3, 4).then(res =&gt; {
                console.log(`It worked! The result is: ${res}`);
            }).catch(err =&gt; {
                console.log(`An error occured: ${err}`); 
            });

            console.log("After");
        </code>
    </pre>
</section>

<section>
    <h2>Warum async / await?</h2>
    <p>Promises funktionieren, sind aber oft schwer lesbar.</p>
    <p><span class="inline-code">async / await</span> macht asynchronen Code lesbarer.</p>
</section>

<section>
    <h2>Asynchrone Funktion</h2>
    <pre><code class="js" data-trim data-line-numbers>
async function loadData() {
    return "Daten geladen";
}
    </code></pre>

    <p>Eine <span class="inline-code">async</span>-Funktion gibt immer ein Promise zurück.</p>
</section>

<section>
    <h2>await verwenden</h2>
    <pre><code class="js" data-trim data-line-numbers>
async function example() {
    const result = await promise;
    console.log(result);
}
    </code></pre>

    <p><span class="inline-code">await</span> pausiert die Funktion, nicht das gesamte Programm.</p>
</section>

<section>
    <h2>Fehler mit try / catch</h2>
    <pre><code class="js" data-trim data-line-numbers>
async function example() {
    try {
        const result = await promise;
        console.log(result);
    } catch (error) {
        console.error(error);
    }
}
    </code></pre>
</section>

<section>
    <h2>Fetch – Daten aus dem Internet</h2>
    <p><span class="inline-code">fetch</span> wird verwendet, um HTTP-Anfragen zu senden.</p>
    <ul>
        <li>Arbeitet asynchron</li>
        <li>Liefert ein Promise zurück</li>
        <li>Wird oft mit APIs verwendet</li>
    </ul>
</section>

<section>
    <h2>Einfacher Fetch</h2>
    <pre><code class="js" data-trim data-line-numbers>
fetch("https://api.example.com/data")
    .then(response => response.json())
    .then(data => console.log(data));
    </code></pre>
</section>

<section>
    <h2>Fetch mit async / await</h2>
    <pre><code class="js" data-trim data-line-numbers>
async function loadData() {
    const response = await fetch("https://api.example.com/data");
    const data = await response.json();
    console.log(data);
}
    </code></pre>
</section>

<section>
    <h2>Typische Fehler bei fetch</h2>
    <ul>
        <li>Netzwerkfehler</li>
        <li>Ungültige URL</li>
        <li>Antwort ist kein JSON</li>
    </ul>
</section>

<section>
    <h2>Fetch mit Fehlerbehandlung</h2>
    <pre><code class="js" data-trim data-line-numbers>
async function loadData() {
    try {
        const response = await fetch("https://api.example.com/data");
        const data = await response.json();
        console.log(data);
    } catch (error) {
        console.error("Fehler beim Laden", error);
    }
}
    </code></pre>
</section>

<section>
    <h2>TL;DR</h2>
    <ul>
        <li>Asynchroner Code blockiert das Programm nicht</li>
        <li>Promises repräsentieren zukünftige Werte</li>
        <li><span class="inline-code">async / await</span> vereinfacht Promises</li>
        <li><span class="inline-code">fetch</span> lädt Daten aus APIs</li>
        <li>Fehler müssen explizit behandelt werden</li>
    </ul>
</section>

</div>
</div>

<script src="dist/reveal.js"></script>
<script src="plugin/highlight/highlight.js"></script>
<script>
    Reveal.initialize({
        hash: true,
        plugins: [RevealHighlight]
    });
</script>

</body>
</html>
